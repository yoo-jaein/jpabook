# jpabook - 스프링 JPA 실습 프로젝트

## 📘 참고자료

- [자바 ORM 표준 JPA 프로그래밍](https://book.naver.com/bookdb/book_detail.nhn?bid=9252528)
- [예제 파일](https://github.com/holyeye/jpabook)

## 🧸 목표
1. 쇼핑몰 홈페이지에 필요한 도메인 모델을 구성해본다.
2. JPA를 이용하여 객체와 테이블을 매핑한다.

## 🔥 진행 상황
- [X] 04장 엔티티 매핑  

+ 회원, 주문, 상품, 주문상품 엔티티를 도출  
  + 회원(MEMBER): 이름(NAME)과 주소 정보를 가진다. 주소는 CITY, STREET, ZIPCODE로 표현한다.  
  + 주문(ORDERS): 상품을 주문한 회원(MEMBER_ID)을 외래 키로 가진다. 주문 날짜(ORDERDATE)와 주문 상태(STATUS)를 가진다. 주문 상태는 ORDER과 CANCEL로 구분한다.  
  + 주문상품(ORDER_ITEM): 주문(ORDER_ID)과 주문한 상품(ITEM_ID)을 외래 키로 가진다. 주문 금액(ORDERPRICE), 주문 수량(COUNT) 정보를 가진다.  
  + 상품(ITEM): 이름(NAME), 가격(PRICE), 재고수량(STOCKQUANTITY)을 가진다. 상품을 주문하면 재고수량이 줄어든다.  

- [X] 05장 연관관계 매핑 기초  

+ 객체 관계는 외래 키를 직접 사용하는 것에서 참조를 사용하도록 변경했다.  

+ 회원과 주문은 일대다 관계고 그 반대는 다대일 관계다.  
  이런 양방향 연관관계에서는 연관관계의 주인을 설정해야 하며 여기에서 외래 키가 있는 Order.member가 주인이다.  
  또한, Order 엔티티에 setMember()라는 연관관계 편의 메소드를 추가했다.  

+ 주문과 주문상품은 일대다 관계고 그 반대는 다대일 관계다.  
  상품에서 주문상품을 참조할 일은 거의 없으므로 주문상품과 상품은 다대일 단방향 관계로 설정했다.  
  즉 OrderItem -> Item 방향으로 참조하는 OrderItem.item 필드만 사용한다.  

- [X] 06장 다양한 연관관계 매핑  

+ 요구사항 추가  
  + 상품을 주문할 때 배송 정보를 입력할 수 있다. 주문과 배송은 일대일 관계다.  
  + 상품을 카테고리로 구분할 수 있다.  
   
+ 주문 Order와 배송 Delivery는 일대일 관계고 그 반대도 일대일 관계다.  
  양방향 연관관계이기 때문에 연관관계의 주인을 Order.delivery로 설정했다.  
  
+ 카테고리 Category와 상품 Item은 다대다 관계고 그 반대도 다대다 관계다.  
  @ManyToMany와 @JoinTable을 사용해서 연결 테이블을 바로 매핑했다.  
  하지만 이런 방식은 연결 테이블에 필드가 추가되면 더는 사용할 수 없으므로 실무에서 활용하기에는 무리가 있다.  
  따라서 다대다 관계를 일대다, 다대일 관계로 풀어서 매핑하는 것이 좋다.  
  
- [X] 07장 고급 매핑  

+ 요구사항 추가  
  + 상품의 종류는 음반, 도서, 영화가 있고 이후 더 확장될 수 있다.  
  + 모든 데이터는 등록일과 수정일이 있어야 한다.  
  
+ 엔티티를 상속 관계로 만들고 공통 속성은 Item 엔티티에 두었다.  
  그리고 Album, Book, Movie 자식 엔티티를 추가했다.  
  상속 관계는 단일 테이블 전략을 선택했다.  
  따라서 ITEM 테이블 하나만 사용하고 DTYPE이라는 컬럼으로 자식 상품을 구분한다.  
  이 방식을 사용하면 조회할 때 조인을 사용하지 않으므로 일반적으로 가장 빠르다.  
  
+ item 패키지를 만들고 Item과 그 자식 클래스들을 모아두었다.  
  그리고 Item 클래스는 직접 생성해서 사용하지 않으므로 abstract를 추가해서 추상 클래스로 만들었다.  
  자식 클래스들에 @DiscriminatorValue 어노테이션을 사용하고 그 값으로 구분 컬럼(DTYPE)에 입력될 값을 정했다.  

+ 두 번째 요구사항을 만족하기 위해 모든 엔티티에 등록일과 수정일을 추가해야 한다.  
  이때 직접 컬럼을 추가하는 것 보다는 @MappedSuperclass를 사용해서 부모 클래스를 만들어 상속받는 것이 효과적이다.  
  부모 클래스는 BaseEntity이고 Member, Order 등의 모든 데이터들에 이 클래스를 상속시켰다.  

- [X] 08장 프록시와 연관관계 관리  

+ 즉시 로딩과 지연 로딩  
  - 즉시 로딩  
    + 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.  
      대부분의 JPA 구현체는 즉시 로딩을 최적화하기 위해 조인 쿼리를 사용한다.  
      설정 방법: @ManyToOne(fetch = FetchType.EAGER)  
      
  - 지연 로딩  
    + 연관된 엔티티를 실제 사용할 때 조회한다.  
      프록시 객체를 사용하여 데이터베이스 조회를 지연시킨다.  
      설정 방법: @ManyToOne(fetch = FetchType.LAZY)  
      
+ JPA 기본 페치 전략  
  연관된 엔티티가 하나면 즉시 로딩, 컬렉션이면 지연 로딩을 사용한다.  
  컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 너무 많은 데이터를 로딩할 수 있다.  
  따라서 모든 연관관계에 지연 로딩을 사용하고, 꼭 필요한 곳에만 즉시 로딩을 사용하도록 한다.    
  @OneToMany, @ManyToMany는 기본이 지연로딩이므로 그냥 두고 @OneToOne, @ManyToOne의 fetch 속성을 지연 로딩으로 설정했다.  
  
+ 영속성 전이  
  특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들 수 있는 기능이다.  
  cascade 옵션으로 활성화한다.  
  주문과 배송, 주문과 주문상품의 연관관계에서 영속성 전이를 사용했다.

- [ ] 09장 값 타입
